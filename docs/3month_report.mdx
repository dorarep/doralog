---
title: 業務委託で入って3ヶ月でやったこと
description: 自分自身の振り返りの意味も込めて、実際に契約を結んでからの3ヶ月に何を考えて何をしたのかをまとめていきたいと思います。
created: 1610150400000
tags: [振り返り]
thumbnail: https://untraten.sirv.com/thumbnails/3month-report.png
---

フルスタックエンジニアで活動してるドラレプです！

今はフリーランスで同時に複数の案件を抱えながら活動しているため面接の機会は多いのですが、なんとなく『フルスタックって役割が見えづらい』『週2-3労働のイメージが湧かない』印象を受けました。

そのため自分自身の振り返りの意味も込めて、実際に契約を結んでからの3ヶ月に何を考えて何をしたのかをまとめていきたいと思います。

# 背景
ざっくり使用技術は以下のようになっています。

- React/Redux/TypeScript
- Elixir/Phoenix
- Kotlin/Javalin

私自身React/Redux/TypeScriptはここ最近はずっと触っていて慣れ親しんだ技術です。
実際にオファーとしてもここの改善を期待されることが多いです。

一方でElixirは初、Kotlinはちょっと触ったぐらいなので、バックエンドに関しては言語・フレームワークの特性をキャッチアップしながら進めていくことになりました。

# 立ち回り

まず全体的にコードを眺めて気になる点が出てきました。

もちろんただタスクをこなす役割でも良いですが、個人的にDXを良くしてから開発に集中したのもありますし、先方としても「改善したい」という話でした。

ですので、この3ヶ月はDX改善を中心に進めていくことにしました。

# フロントエンド
まずは、フロントエンドを中心に改善していきました。
理由は、次のとおりです。

- バックエンドに比べ重篤な不具合に繋がりづらい。
- バックエンドに比べコードを捨てやすい。
- 技術背景的に良く知ってるので、改善点も見つかりやすい。
- 小手先の改善で大きなリターンが得られやすい。

## linterの調整
全体に対して`fix`かけるタイミングさえ用意できれば問題も起きづらい箇所なので、まずはlinterの設定から直していきました。

課題感としては、次のような点でした。

- deprecatedであるtslintを採用していた
- `eslint-disable-nextline`ほぼ全てのファイルで行なっていた

そのためeslint/prettierの構成にし、ルールのカスタマイズ、ReactPluginの追加などで基本は`disable`せずに開発できるようにしました。

## TypeScript周り
TypeScriptを採用していたのですが、以下のような課題感がありました。

- 型定義されてない箇所が多かった
- 型エラーが放置されていた
- anyやas、non-null assertionが多用されていた

これは、次のような負のスパイラルに陥ってるためと考えました。

1. エラーを直す場当たり的な対応が中心となってしまう
2. 型の恩恵が受けられなくなっていく
3. 型定義するモチベーションが湧かない

そのため、「useSelectorでちゃんと推論されて便利」みたいな体験を積み重ねていくために、まず型の恩恵を受けられるようにすることをゴールに置いていきます。
とはいえ大幅な変更はメンバーがついてこれないこともあるので、反応を見つつ少しずつ進めていきました。

### 型エラーの検知

既存の型エラーを全て修正し、CIで`tsc`を回すようにしました。

TypeScriptのコンパイルをbabelからwebpackに移せばwatch時に型エラーを検知できるようになるのですが、Elixirからwebpackを呼び出していてlogが見づらい設計になっていたので、あまりワークしませんでした。

将来的にはElixirから切り離して自分でwatchする運用にしたい気持ちもありますが、課題自体は解決できたので深入りはやめました。

### anyやas、non-null assertionが多用され、実質型が機能していなかった

ちょっとずつ修正していき、strictに変更しました。

またNon-null assertionについてはネストの深いオブジェクトのnullチェックを面倒に感じて使われてるように見えました。

そのためTypeScriptのバージョンを上げ、Optional Chainingを使えるようにしました。

### Redux周りの型定義の充実

特にRedux周りの型が全然定義されておらず、特にStoreに何が入るのかコードを追わないとわからない状態でした。

例えばuseSelectorで以下のように呼び出し先で毎回定義されており、後から変更もしづらい状況でした。

```ts
useSelector((state: { user: { auth: { token: string }}}) => state.user.auth.token)
```

まず実装を見ながら定義し直し、DefaultRootState等の設定をしました。

これによりRootStoreの型が全体に適用され、useSelectorでの型指定が不要になりました。

また自力で型定義すると複雑になりそうな形になっていたので、`redux-tool-kit`を採用し、ライブラリに頼れば型が付与されるようにました。

一緒に入ったredux-devtoolsもDX向上に大きく貢献します。

## Style周りの問題

課題感としては以下の通りです。

- Global CSSに色々な定義が入った上で、CSS Modulesが色々なComponentから参照していた。
  - 一つの変更の影響箇所が大きく、UIが壊れやすかった。
- 歴史的に色々な外部のデザイナーが設計していたらしく、UIが統一されていなかった。

### 方針の策定

Mgr/現在の担当デザイナーも同様の問題意識を持っていたので、以下の要素をデザイナー中心に提案してもらう流れとなりました。

- Colorやマージンのルール
- px/remの方針
- ButtonやCardなどの基幹コンポーネントのデザイン

今後のUIに関してはその方針に従い、既存のものについては少しずつ統一させていく方針となりました。

### Styled Component

CSS Modules自体も悪い技術ではないものの、今の運用では依存関係がぐじゃぐじゃになりやすい課題感がありました。

方針を相談したところ現フロントエンドメンバーはStyled Componentを使いたいとのことで、導入を進めてくれました。

ちなみに課題感だけ見るとShadowDOMを使いたい気持ちはありました。

## その他
### CIでのStorybookの生成
デザイナーにStorybookを自分でgenerateして、zipファイルを渡す運用をしていました。

そのためCI上でStorybookをgenerateしてartifactへ格納するようにしました。

これにより、コードレビュー時に手元でcheckoutしなくても動作確認できるようになりました。

### Responsiveロジックの改善
sp/pcの判定ロジックがglobalに格納されていて、一度計算されたら再計算されない実装になっていました。

そのためまずStateに保持するCustom Hookである`useMedia`を作り、変更に合わせ再計算・再描画されるようにしました。

ただそれだとStyled Componentに渡すのが面倒とのことだったので、styled-media-queryっぽいものも作りました。

# OpenAPI
フロントエンドの型の課題の延長として、バックエンドからの戻り値の型定義の問題がありました。

そのためOpenAPI Schemaを橋渡しにコードの自動生成をすることで一貫性を持たせるため方針を相談しました。

## 状況
今はバックエンドのOpenAPI Schemaを独自定義する運用になっていました。

ただあくまでコミュニケーションツールとして独立して運用されていたため、Schemaとコードの整合性の担保は取れていない状況でした。

## バックエンドからSchemaの自動生成
今の開発スタイル的にスキーマファーストよりバックエンドからswagger.yamlを自動生成した方が良いとの結論に至りました。

そのためフレームワークのOpenAPI Pluginからバックエンドのコードから自動でswagger.yamlを出力するようにしました。

これによりAPIの動作テストもSwaggerUI上からできるようになりました。

## Schemaからクライアントの自動生成

Swagger Codegenでバックエンドが生成したSchemaからClientを自動生成できるようにしました。

また、クライアントからAPIを呼び出せるCustom Hookを用意しました。

# バックエンド
ざっくり全体の構成として以下のようになっていました。

- Auth: Elixir
- v1: Elixir
- v2: Kotlin

Elixirを辞めるために新規機能をマイクロサービスとして切り出し(v2)、v1とv2でチームが分かれたとのことです。

そのためv1->v2->authと通信していたり、v2->v1と通信していたり、他サービスのDBを直接参照していたり、依存関係が複雑になっていました。

つまり歴史的背景からサービスの機能や役割が中途半端になっている状況でした。

## 方針の策定

過去の実装を見ても、Microservices vs Monolithでメンバーによって目指す方向性が違っているように感じられました。

- v1とv2の役割が実質被っているところがある
- v1の一部機能がなくなったため、v1の役割が減った
- Elixirは辞めたいという意向がある

とのことで、まずはv1をv2に統合していき、その後必要に応じて機能を切り出すことを提案しました。

## テストの充実化

大幅なリファクタリングをするためには、テストを充実させる必要があります。

Active Recordパターンで書かれており、DB操作を含んだテストが書きづらい状況にありました。

そのためほとんどがインテグレーションテストで書かれているのですが、実行時のDBの状態に依存しているため壊れやすいものでした。

### Testcontainerの採用
Repositoryパターンを採用してインフラ層はDIする方向性も話しましたが、設計変更はしたくないとのことでした。

そのためTestcontainerを使いクリーンなテスト用DBを用意する方針にしました。

これによりUnitテストでDB操作を含んだテストが書けるようになりました。

### E2Eテストの追加

v2でインテグレーションテストが書かれていたのですが、それだとv2を起点にしたテストしかできません。

v1をv2に移行するにあたり一番表側にあるフロントエンドから統合テストする必要があるため、E2Eテストを追加しました。

## DDD
「DDDをしている」とのことだったのですが、戦略的DDDはしておらず、Aggregateパターン、Repositoryパターンなども採用されていませんでした。

あまりポジティブな反応は得られませんでしたが、純粋に困った点があったので次の提案をしました。

### ユビキタス言語の策定

複雑なドメインを扱っているが用語が統一されていないため、コードリーディングが困難でした。

- 同じ概念をさす用語が複数ある
- 複数の概念を1つのクラスで扱っている
- フロントエンドとバックエンドで用語が統一されていない

そのためせめてエンジニア内だけでも言語を統一できないか相談しました。

### ドメインモデリング

一度サービスの全体像を理解するために、一緒にゼロベースでドメインモデリングを行いました。

自分としてもドメイン知識が深まり、既存のコードとの関連性も見えてきました。

また元々のメンバーも曖昧だった点がクリアになったようでした。

# DevOps

会社として自己組織化した組織を作ることが目標になっているとのことでした。

ただ実態としてエンジニア組織は正社員1人と業務委託のチームになっていて、正社員1名を中心に回っている形になっていました。

具体的にはコードレビュー・デプロイ・動作確認・他業種との調整・開発内容決定・開発方針決定などを全て1人で行っており、その他は割り振られた作業を行うだけでした。

## 悩んだ点

自己組織化を目指すなら教科書的にやれることはありますが、チームメンバーが本当にこの状況を変えたいと思ってるのか分かりませんでした。

ボールを投げてみてもあまりポジティブな反応は感じられなかったので、一旦目先の課題を解決することにしました。

## 自動化を進める

正社員の方の多くは確認の工数に取られているようで、特にデプロイのたびに人力で全体的な機能の動作確認を行ってるようでした。

背景としてテストへの信頼性の低さや、全システムの一貫したテストがないことが想定されました。

これもE2Eテストを提案した背景の1つとしてあります。

# 今後やりたいこと
## DevOps

デプロイをより自動化したり、インフラ構成の最適化、datadogなどモニタリングツールの採用など、やれることはまだまだありそうのですが、DevOpsチームが担当してるとのことでした。

そのため直近としてはCI上でインテグレーションテストを回すなど、できる範囲での自動化を進めようとしています。

## エラーハンドリング
バックエンドとしてはあまりハンドリングされておらず、多くは500で返却されていました。

フロントエンドは`catch`していないか`setError(“エラーが発生しました”)`をし、UIのどこかで`error`を表示してるだけでした。

そのためバックエンドでエラーメッセージを返すようにし、結果がエラーだあったらToastでメッセージを表示する処理を含めたCustom Hookを作ればよりユーザフレンドリーになりそうです。

# おわりに

ということで、配属から3ヶ月で実際に考えやってきたことをまとめました。

基本方針として絶対的な答えはないと思ってるので、自分の考えを述べた上で意思決定は現場に委ねようと思っています。

たとえばMicroservices vs Monolithや、DDDを教科書通りに行うのかなど、結局どちらもPros/Consがあります。

面接だとどうしても空中戦となり『理論上最強』な話になりがちですが、現場では柔軟に対応していきたいと思うので、よろしくお願いします！
